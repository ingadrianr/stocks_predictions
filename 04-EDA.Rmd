```{r 04-0, include=FALSE}
library(tidyquant)
library(TTR)
library(ggplot2)
library(tidyquant)
library(tidyverse)
library(ggplot2)
library(scales)
library(tseries)
library(stats)
library(dplyr)
library(ggpubr)
```

# Análisis Exploratorio de Datos

Se inicia el análisis exploratorio de los datos recopilando la información de cada una de las empresas Top 10 del índice S&P 500. Se define la variable <i>empresas</i> a la cuál se le asignan las empresas definidas en el numeral <b>2.1.</b>, como también como los rangos de las fechas donde se realizará la consulta de los datos:

```{r 04-1, warning=FALSE, message=FALSE}
empresas = c("AAPL", "MSFT", "AMZN", "NVDA", "GOOGL","BRK-B","GOOG", "META","UNH","XOM")
precios <- tidyquant::tq_get(empresas, from = "2022-01-01", to = "2023-04-30", get = "stock.prices")
```

Como se puede observar en la siguiente tabla, para cada empresa se cuenta con los atributos de propios para cada acción, que indica su símbolo y atributos relacionados con los precios: <i>symbol</i>, <i>open</i>, <i>high</i>, <i>low</i>, <i>close</i>, <i>volume</i> y <i>adjusted</i>.

```{r 04-2, warning=FALSE, message=FALSE, echo=FALSE}
head(precios)
```

A partir de esta información se grafican los valores de cada una de las acciones con respecto al tiempo, obteniendo la siguiente figura:

```{r 04-3, warning=FALSE, message=FALSE, fig.align='center'}
ggplot2::ggplot(data = precios) +
  ggplot2::geom_line(aes(x = date, y = close, color = symbol)) +
  ggplot2::labs(title = 'Precio cierre por accion desde 2022-01-01 a 2023-04-30', 
                y = 'Close Price',
                x = 'Date')
```

De la figura anterior se pueden identificar preliminarmente algunas tendencias, como de que la acción de Unitedhealth Group Inc <b>UNH</b> mantiene un precio relativamente constante durante el transcurso del 2022. 

## Comportamiento Inicial Series

Con la finalidad de ahondando en la exploración inicial de los datos de las empresas definidas, se intentará identificar ciertas tendicias en los datos, para ello, se debe realizar un filtro o suavizado con el objeto de reducir el ruido y oscilaciones con los que los datos pudieran contar. Es aquí donde se involucran los términos de promedio móvil y rezagos. 


### Promedio Móvil y Rezagos

El principio de funcionamiento de este método es tomar los últimos <i>k</i> valores de una serie para calcular el promedio y asignarlo al valor del siguiente periodo; la ventana de tiempo utilizada para realizar este cálculo se va desplazando a medida que nuevas observaciones vayan surgiendo [7]. A continuación se presenta la función de promedios móviles de orden simple:

\begin{align*}
F_{t+1} = \frac{Y_t + Y_{t-1} + ... + Y_{t-k+1}}{k} \\
\end{align*}

Luego de esta definición, se procede a calcular para cada una de las series de tiempo de las empresas definidas el promedio móvil. Se define un valor de <i>k=5</i>, así:

```{r 04-4, warning=FALSE, message=FALSE, fig.height=20, fig.width=15}
stock_plots = list()

for (symbol in unique(precios$symbol)){
  stock_data = stats::ts(precios[precios$symbol == symbol, 'close'])
  ma = zoo::rollmean(stock_data, k = 5, align = "right")
  
  stock_data = data.frame(stock_data)
  ma = data.frame(ma)
  
  stock_plots[[symbol]] = ggplot2::ggplot() + 
    ggplot2::geom_line(data = stock_data, aes(x = index(stock_data), y = close), color = 'gray') +
    ggplot2::geom_line(data = ma, aes(x = index(ma), y = close), color = 'salmon') +
    ggplot2::labs(title = symbol, x = 'days')
}

ggpubr::ggarrange(plotlist = stock_plots, ncol = 2, nrow = 5)  
```

Conforme al gráfico anterior podemos identificar que la gráfica del promedio móvil se ajusta en gran proporción a la serie de tiempo; en casos como para la acción <i>GOOGL</i> se podría de cierta forma establecer una tendencia a la baja. En este punto, puede surgir la pregunta sobre si los datos traen embebidos información adicional, ¿hay datos estacionales?, ¿cómo se comporta el error?... esto se puede evaluar a través de la evaluación de la estacionalidad o descomposición de la serie de tiempo. 

### Estacionalidad (Descomposicion Aditiva) 

Asumiendo que la serie de tiempo es de tipo aditiva de acuerdo con [8], se pueden definir ciertos componentes de esta. En principio una serie de tiempo consta de varios componentes, <i>tendencia</i>, <i>estacionalidad</i> y <i>error</i>; definida por la siguiente formula:

\begin{align*}
Y_t = S_t + T_t + R_t
\end{align*}

donde,

$Y_t =$ Serie de tiempo en un periodo t \
$S_t =$ Componente estacionial en un periodo t \
$T_t =$ Componente de tendencia en un periodo t \
$R_t =$ Error en un periodo de t \

Se realiza la descomposición de cada una de las series de tiempo definidas anteriormente:

```{r 04-5, warning=FALSE, message=FALSE}

for (i in unique(precios$symbol)){
  stock_data <- ts(precios[precios$symbol == i, "close"], frequency=5)
  decomposition <- decompose(stock_data, type = "additive")
  plot(decomposition)

}
```

## Estacionaridad


Explicar que es


### Prueba Dickey- Fuller (ADF) Series naturales{-}

Dar un contexto de la prueba, escribir las hipotesis, por cada accion definir si es o no estacionaria.
sobre las que no son estacionarias, debemos evaluar alternativas como la diferenciacion

<br>
* Hipótesis nula: La serie de tiempo tiene una raíz unitaria. La serie de tiempo es no estacionaria.

* Hipótesis alternativa: La serie de tiempo no tiene raíces unitarias. La serie de tiempo es estacionaria.


```{r 04-6, warning=FALSE, message=FALSE}
for (column in unique(precios$symbol)) {
  stock_data <- ts(precios[precios$symbol == column, "close"])
  result <- adf.test(stock_data)
  cat(paste("Acción: ", column, "\n"))
  cat(paste("ADF Estadística: ", result$statistic, "\n"))
  cat(paste("Valor p: ", result$p.value, "\n"))
  for (key in names(result$critical)) {
    cat(paste("   ", key, ": ", result$critical[key], "\n"))
  }
  cat("-----------------------\n")
}
```




### ACF y PACF {-}

Hablar para que sirven que normalmente sirven para definir los ordenes del modelo autoregresivo (AR) y del modelo de media movil (MA)... Interpretar solo en una acción.

```{r 04-7, warning=FALSE, message=FALSE}
precios_df=as.data.frame(precios)


for (i in unique(precios$symbol)) {
  stock_i <- subset(precios, symbol == i)
  stock_ts <- ts(stock_i$close)
  
  stock_acf <- acf(stock_ts,plot = FALSE)
  stock_pacf <- pacf(stock_ts,plot = FALSE)
  
  par(mfrow=c(1,2))
  plot(stock_acf, main=paste("ACF para la acción", i))
  plot(stock_pacf, main=paste("PACF para la acción", i))

}

```

### Diferenciación {-}
Explicar como se usa y para que sirve.Ventajas y Desventajas

```{r 04-8, warning=FALSE, message=FALSE}

precios <- precios %>% 
  group_by(symbol) %>% 
  mutate(diferenciado1 = c(NA, diff(close, differences = 1)[-length(close)]))

head(precios)
```

### Prueba Dickey- Fuller (ADF) Series diferenciadas {-}

Concluir si sirvio para volver estacionarias las series.


```{r 04-9, warning=FALSE, message=FALSE}
symbols_no_estacionarios <- setdiff(unique(precios$symbol), "XOM")

for (column in symbols_no_estacionarios) {
  stock_data <- precios[precios$symbol == column, ]
  stock_data_omit_na <- na.omit(stock_data$diferenciado1)
  result <- adf.test(stock_data_omit_na)
  cat(paste("Acción: ", column, "\n"))
  cat(paste("ADF Estadística: ", result$statistic, "\n"))
  cat(paste("Valor p: ", result$p.value, "\n"))
  for (key in names(result$critical)) {
    cat(paste("   ", key, ": ", result$critical[key], "\n"))
  }
  cat("-----------------------\n")
}
```

